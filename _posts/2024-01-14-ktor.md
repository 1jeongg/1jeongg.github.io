---
layout: post
title:  "Ktor 2.3.3 í”„ë¡œì íŠ¸ì— ì ìš©"
author: 1jeongg
categories: [ ì•ˆë“œë¡œì´ë“œ ]
summary: ë¹„ë™ê¸° ë°©ì‹ìœ¼ë¡œ http í†µì‹ ì„ ë„ì™€ì£¼ëŠ” í”„ë ˆì„ì›Œí¬ì¸ Ktorì˜ ì‚¬ìš©ë°©ë²•ê³¼ í›„ê¸°ë¥¼ ê¸°ë¡í•˜ì˜€ìŠµë‹ˆë‹¤.
tags: 
---

> ğŸ¤” Ktor(ì¼€ì´í† )ë€?   
> 
> JetBrainsì—ì„œ ê°œë°œë˜ì—ˆìœ¼ë©° ë‹¨ìˆœí•œ ë°©ë²•ìœ¼ë¡œ ë©€í‹°í”Œë ›í¼ http í´ë¼ì´ì–¸íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“œëŠ” í”„ë ˆì„ì›Œí¬    
> ë¹„ë™ê¸° ë°©ì‹ìœ¼ë¡œ í´ë¼ì´ì–¸íŠ¸ ë° ì„œë²„ ì•±ì„ ì‘ì„±í•  ìˆ˜ ìˆë„ë¡ ë„ì™€ì¤€ë‹¤.

ì°¸ê³ : í˜„ì¬ ê¸€ì€ ktor 2.3.3 ë²„ì „ì„ í† ëŒ€ë¡œ ì„¤ëª…í•©ë‹ˆë‹¤. minsdkëŠ” 26, compileSdkì™€ targetSdkëŠ” 34
 
## â“ Ktorë¥¼ ì“°ëŠ” ì´ìœ ?
ê³µì‹ ë¬¸ì„œ ë‚´ìš©
> 1ï¸âƒ£ ì½”í‹€ë¦°ê³¼ ì½”ë£¨í‹´ ì‚¬ìš© ê°€ëŠ¥
> 
> 2ï¸âƒ£ JetBrainì‚¬ì—ì„œ ë§Œë“¦
> 
> 3ï¸âƒ£ ê²½ëŸ‰ì„±ê³¼ ìœ ì—°ì„±

ê¸°íƒ€
> 1ï¸âƒ£ Scope í• ë‹¹í•˜ì—¬ DSL í˜•ì‹ì´ë¼ ê°€ë…ì„± ë†’ìŒ
> 
> 2ï¸âƒ£ Serialization ì§€ì›
> 
> 3ï¸âƒ£ ê°€ë…ì„±ì´ ì¢‹ê³  ìœ ì§€ ë³´ìˆ˜ê°€ ì‰¬ì›€

## Retrofitê³¼ì˜ ë¹„êµ

ktorëŠ” retrofitê³¼ ë‹¬ë¦¬ jvmì— ì˜ì¡´ì„±ì´ ì—†ìŒ

KMM(Kotlin Mutliplatform Mobile) í™˜ê²½ì—ì„œ ì‚¬ìš©í•˜ê¸° ì í•©í•¨

ktorëŠ” Retrofitê³¼ ë‹¬ë¦¬ Setup ê³¼ì •ì´ ê°„ì†Œí™”ë˜ì–´ìˆìŒ

ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œ Ktorë¥¼ ì‚¬ìš©í•œ ì´ìœ : ê·¸ì € KMMìœ¼ë¡œì˜ í™•ì¥ì„±ì„ ê³ ë ¤í•´ì„œ ê·¸ë ‡ê²Œ ì„¤ê³„í–ˆë‹¤.

Composeê°€ iosì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ìˆê²Œ ë³€í•˜ê³ , KMMì„ í†µí•´ ë°ìŠ¤í¬íƒ‘ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ë§Œë“¤ ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ìƒˆë¡œìš´ í”„ë ˆì„ì›Œí¬ë¥¼ í™œìš©í•´ì„œ í”„ë¡œì íŠ¸ë¥¼ ì§„í–‰í•˜ê³  ì‹¶ì—ˆë‹¤.

ìƒˆë¡œìš´ ê±¸ ë„ì „í•˜ëŠ” ê±´ ëŠ˜ ì¬ë°Œê¸°ì—,, ì—¬ë¦„ ë°©í•™ë™ì•ˆ ê³µë¶€í•´ë³´ë©´ì„œ ì ìš©í•´ë³´ê¸°ë¡œ í–ˆë‹¤.

## ğŸš€ ì‚¬ìš© ë°©ë²•
### 0. gradle ì„¤ì •
```kotlin
build.gradle.kt(Module :app)

plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("kotlin-kapt")
    id("dagger.hilt.android.plugin")
    id("org.jetbrains.kotlin.plugin.serialization")
}

// ktor dependency
implementation("io.ktor:ktor-client-core:2.3.3")
implementation("io.ktor:ktor-client-cio:2.3.3")
implementation("io.ktor:ktor-client-logging:2.3.3")
implementation("io.ktor:ktor-client-content-negotiation:2.3.3")
implementation("io.ktor:ktor-serialization-kotlinx-json:2.3.3")
implementation("org.jetbrains.kotlinx:kotlinx-datetime:0.4.0")
implementation("io.ktor:ktor-client-auth:2.3.3")
implementation("io.ktor:ktor-client-encoding:2.3.3")

// need for test
implementation("com.google.ar:core:1.39.0")
implementation("androidx.test.ext:junit-ktx:1.1.5")
testImplementation("io.ktor:ktor-client-mock:2.3.3")
implementation("org.slf4j:slf4j-simple:1.7.32")

testImplementation("org.mockito.kotlin:mockito-kotlin:4.1.0")
testImplementation("androidx.arch.core:core-testing:2.2.0")
testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.2")
testImplementation("io.mockk:mockk:1.12.0")
androidTestImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.2")

```

build.gradle.kt(Project)
```kotlin

buildscript{
    repositories {
        google()
        mavenCentral()
    }
    dependencies {
        classpath("com.android.tools.build:gradle:7.2.2")
        classpath("org.jetbrains.kotlin:kotlin-gradle-plugin:1.5.21")
        classpath("com.google.dagger:hilt-android-gradle-plugin:2.47")
        classpath("org.jetbrains.kotlin:kotlin-serialization:1.8.10")
    }
}
plugins {
    id("com.android.application") version "8.1.0" apply false
    id("com.android.library") version "8.1.0" apply false
    ...
}
 ```

### 1. DTO ì„¤ì •
```kotlin
@Serializable
data class ScrapDTO(
    val contentId: Long,
    val contentTitle: String,
    val link: String,
    val pubDate: LocalDateTime,
    val isScrap: Boolean
)
```
ktorì—ì„œëŠ” json serializationì„ ì‚¬ìš©í•  ê²ƒì´ê¸°ì— ë‹¤ìŒê³¼ ê°™ì´ Serializable ì–´ë…¸í…Œì´ì…˜ì„ ë‹¬ì•„ì£¼ì–´ì•¼ í•œë‹¤. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì—ëŸ¬ë‚¨.

### 2. ê°„ë‹¨í•œ Request ë³´ë‚´ê³  ë°›ê¸°

```kotlin
val customer: Customer = client.get("http://localhost:8080/customer/3").body()
```

ë‹¤ìŒ ì½”ë“œëŠ” id 3ì„ ê°€ì§„ ê³ ê°ì— ëŒ€í•œ json ë°ì´í„°ë¥¼ ë°›ì•„ì˜¨ë‹¤.

ì´ëŸ° ì‹ìœ¼ë¡œ get, post, delete ë“± ë‹¤ì–‘í•œ ë©”ì„œë“œë¥¼ ì ìš©í•  ìˆ˜ ìˆë‹¤. ì´ì™¸ì—ë„ form data ë“±ì„ ì‚¬ìš©í•  ìˆ˜ ìˆê³  ë‹¤ì–‘í•œ parameter, query ë“±ì„ ì¶”ê°€í•  ìˆ˜ ìˆë‹¤.

ì—¬ê¸°ì— ëŒ€í•´ ëª¨ë“  ê²ƒì„ ë‹¤ë£¨ê¸°ëŠ” ì‚¬ì‹¤ í˜ë“¤ ê²ƒ ê°™ì•„ì„œ ì‹¤ì œ ë‚´ê°€ ì ìš©í•œ í”„ë¡œì íŠ¸ì˜ ìŠ¤í¬ë© ê¸°ëŠ¥ì„ í† ëŒ€ë¡œ ì„¤ëª…í•´ë³´ê² ë‹¤.


### 3. HttpClientì™€ ì—°ê²°ë˜ëŠ” ScrapApi

```kotlin
class ScrapApi(
    private val client: HttpClient
): ScrapRepository {

    override suspend fun getScrapList(subscribeId: Long?, page: Int?): HttpResponse {
        val path = if (subscribeId == null) "" else "/$subscribeId"
        return client.get(HttpRoutes.GET_SCRAPS + path){
            parameter("page", page)
        }
    }

    override suspend fun addScrap(contentId: Long): HttpResponse {
        return client.post(HttpRoutes.ADD_SCRAP + "/$contentId"){}
    }

    override suspend fun deleteScrap(contentId: Long): HttpResponse {
        return client.post(HttpRoutes.DELETE_SCRAP + "/$contentId"){}
    }

}
```

HttpClientë¥¼ ì´ìš©í•´ì„œ requestë¥¼ ë³´ë‚´ëŠ” ì½”ë“œì´ë‹¤.

getScrapListëŠ” êµ¬ë…í•œ subscribe_idì— ë”°ë¼ ìŠ¤í¬ë©í•œ ë¦¬ìŠ¤íŠ¸ë¥¼ í˜ì´ì§€ë³„ë¡œ ë¶ˆëŸ¬ì˜¤ëŠ” ì½”ë“œë‹¤. ì´ë•Œ pageì™€ subscribe_idëŠ” ë¹„ì–´ìˆì„ ìˆ˜ ìˆë‹¤. ë‹¤ìŒ ì½”ë“œì—ì„œ ìš”ì²­í•˜ëŠ” urlì€ URL/{subscribe_id}?page=2 ì´ë‹¤.

addScrapì€ í•´ë‹¹ contentì„ ìŠ¤í¬ë©í•œ ë¶€ë¶„ì— ì¶”ê°€í•˜ê³  deleteScrapì€ ì‚­ì œí•œë‹¤. urlì€ URL/{content_id} ì´ë‹¤.

### 4. ScrapApiì™€ ScrapRepositoryImplë¥¼ ì´ì–´ì£¼ëŠ” Interface
```kotlin
interface ScrapRepository {
    suspend fun getScrapList(subscribeId: Long?, page: Int?): HttpResponse
    suspend fun addScrap(contentId: Long): HttpResponse
    suspend fun deleteScrap(contentId: Long):HttpResponse
}
```

### 5. ScrapRepositoryì˜ ë‚´ìš©ì„ implementí•˜ëŠ” ScrapRepositoryImpl
 
```kotlin
@Singleton
class ScrapRepositoryImpl @Inject constructor(
    private val scrapApi: ScrapApi
): ScrapRepository{

    override suspend fun getScrapList(subscribeId: Long?, page: Int?): HttpResponse {
        return scrapApi.getScrapList(subscribeId, page)
    }

    override suspend fun addScrap(contentId: Long): HttpResponse {
        return scrapApi.addScrap(contentId)
    }

    override suspend fun deleteScrap(contentId: Long): HttpResponse {
        return scrapApi.deleteScrap(contentId)
    }
}
```

### 6. ê° methodë¥¼ ìˆ˜í–‰í•˜ëŠ” Usecase
```kotlin
class AddScrap @Inject constructor(
    private val scrapRepository: ScrapRepository
){
    operator fun invoke(contentId: Long): Flow<Resource<String>> = flow {
        try {
            emit(Resource.Loading())
            val response = scrapRepository.addScrap(contentId)
            val body = response.body<ApiUtils.ApiResult<String>>()
            val successMessage = body.response ?: "ì„±ê³µì ìœ¼ë¡œ ìŠ¤í¬ë© ì™„ë£Œí–ˆìŠµë‹ˆë‹¤."
            val errorMessage = body.error?.message ?: "ìŠ¤í¬ë©ì— ì‹¤íŒ¨í•˜ì˜€ìŠµë‹ˆë‹¤."

            if (response.status == HttpStatusCode.OK && body.success) {
                emit(Resource.Success(successMessage))
            }
            else {
                emit(Resource.Error(errorMessage))
            }
        } catch(error: Exception){
            emit(Resource.Error(getErrorMessage(error)))
        }
    }
}
```
ì„œë²„ responseì—ì„œ í•œ ë²ˆë” ì„±ê³µ ì—¬ë¶€ë¥¼ ì•Œë ¤ì£¼ê¸°ì— ì´ë¥¼ ê²€ì¦í•˜ëŠ” ë¡œì§ì„ ì¶”ê°€í•˜ì˜€ë‹¤.

### 7. í†µì‹ ì„ ê´€ë¦¬í•˜ëŠ” ë„¤íŠ¸ì›Œí¬ ëª¨ë“ˆ
```kotlin
@Module
@InstallIn(SingletonComponent::class)
class NetworkModule {
    @Provides
    @Singleton
    fun provideHttpClient(
        @ApplicationContext context: Context
    ): HttpClient {
        return HttpClient(CIO) {
            install(Logging){
                logger = object: Logger {
                    override fun log(message: String){
                        Log.d("ppap_api", message)
                    }
                }
                level = LogLevel.ALL
            }
            install(ContentNegotiation) {
                json(Json{
                    prettyPrint = true
                    isLenient = true
                    encodeDefaults = true
                })
            }
            install(HttpTimeout) {
                connectTimeoutMillis = 5000
                requestTimeoutMillis = 5000
                socketTimeoutMillis = 5000
            }
            install(Auth){
                bearer {
                    refreshTokens {
                        ...
                    }
                }
            }
            install(ContentEncoding) {
                deflate(1.0F)
                gzip(0.9F)
            }
            defaultRequest{
                val accessToken = PDataStore(context).getData(ACCESS_TOKEN_KEY)
                contentType(ContentType.Application.Json)
                if (accessToken.isNotEmpty())
                    headers.appendIfNameAbsent(HttpHeaders.Authorization, accessToken)
                url(HttpRoutes.BASE_URL)
            }
        }
    }

    @Provides
    @Singleton
    fun provideScrapApi(client: HttpClient): ScrapRepository {
        return ScrapApi(client)
    }
    @Provides
    @Singleton
    fun provideScrapRepositoryImpl(scrapApi: ScrapApi): ScrapRepositoryImpl {
        return ScrapRepositoryImpl(scrapApi)
    }
}

```

ë„¤íŠ¸ì›Œí¬ ëª¨ë“ˆì´ë‹¤. dependency injectionì„ í•´ì£¼ë©° ktor ì„ í†µí•œ ë¹„ë™ê¸° í†µì‹ ì„ ìœ„í•œ ë‚´ìš©ë“¤ì„ ì œê³µí•œë‹¤. ì‚¬ì‹¤ ContentNegotiationê³¼ Loggingì„ ì œì™¸í•˜ë©´ í•„ìš”í•˜ì§€ ì•Šë‹¤ë©´ ì•ˆ ì ì–´ë„ ëœë‹¤.

a. Logging

í•´ë‹¹ requestì— ëŒ€í•œ ë¡œê·¸ë¥¼ ì°ì–´ì¤€ë‹¤. ë‚˜ëŠ” ì¼ë°˜ ë¡œê·¸ëŠ” `ppap_log`ë¡œ, api ë¡œê·¸ëŠ” `ppap_api`ë¡œ ì„¤ì •í•˜ì—¬ í•„í„°ë§í•  ë•Œ `ppap_` ë¥¼ ì¨ì„œ í™•ì¸í•˜ì˜€ë‹¤.
ë¡œê¹… ë ˆë²¨ì€ ALL, HEADERS ë“±ìœ¼ë¡œ ì„¤ì •í•  ìˆ˜ ìˆê³  ê·¸ ì™¸ì—ë„ filterë¥¼ í†µí•´ ~í•œ íŒ¨í„´ì„ ê°€ì§„ urlì„ í˜¸ì¶œí•˜ëŠ” requestì˜ ë¡œê·¸ë§Œ ë³¼ ìˆ˜ë„ ìˆë‹¤.

b. ContentNegotiation
ì´ë²ˆ í”„ë¡œì íŠ¸ì—ì„œëŠ” JSONì„ ì‚¬ìš©í•˜ê¸°ì— JSON serializerë¥¼ ì‚¬ìš©í•˜ì˜€ì§€ë§Œ XML, CBOR, ProtoBufë„ ì§€ì›í•œë‹¤.

c. HttpTimeout
http í†µì‹ ì„ í•˜ëŠ”ë° í•œì°¸ ê±¸ë¦¬ë©´ ì‚¬ìš©ìê°€ ë¶ˆí¸í•  ê²ƒì´ê¸°ì— 5ì´ˆì˜ timeoutì„ ê±¸ì–´ë‘ì—ˆë‹¤.

d. Auth
refreshTokenê³¼ asccessTokenì„ ê´€ë¦¬í•  ìˆ˜ ìˆëŠ” ë¶€ë¶„ì´ë‹¤.
accessTokenì€ ì•„ë˜ defaultRequestì—ì„œ ë³´ë‚´ê¸° ë•Œë¬¸ì— í•´ë‹¹ ë¶€ë¶„ì—ì„  ìƒëµí•˜ì˜€ë‹¤.
ë°˜ë©´ ì„œë²„ì˜ token ìœ íš¨ê¸°ê°„ì€ 30ë¶„ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆê¸° ë•Œë¬¸ì— 403 ì—ëŸ¬ê°€ ë‚˜ë©´ ìë™ìœ¼ë¡œ refresh í•˜ê³  responseë¡œ accessTokenê³¼ refreshTokenì„ ë°›ì•„ì„œ ì´ë¥¼ ë‹¤ì‹œ ì €ì¥í•˜ëŠ” ë¡œì§ì´ í•„ìš”í–ˆë‹¤.
ë”°ë¼ì„œ ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œë¥¼ ì‘ì„±í•˜ì˜€ë‹¤. (... ì•ˆì— ë“¤ì–´ìˆëŠ” ë‚´ìš©)

```kotlin
refreshTokens {
    val refreshToken = PDataStore(context).getData(REFRESH_TOKEN_KEY)
    val token = client.post(HttpRoutes.KAKAO_REISSUE){
        setBody(RefreshTokenDTO(refreshToken))
        markAsRefreshTokenRequest()
    }.body<ApiUtils.ApiResult<KakaoLoginDTO>>()

    if (token.success){
        PDataStore(context).setData(ACCESS_TOKEN_KEY, token.response?.accessToken ?: "")
        PDataStore(context).setData(REFRESH_TOKEN_KEY, token.response?.refreshToken ?: "")
    }
    BearerTokens(
        accessToken = token.response?.accessToken ?: "",
        refreshToken = token.response?.refreshToken ?: ""
    )
}
```

e. ContentEncoding
íŠ¹ì • ì••ì¶• ì•Œê³ ë¦¬ì¦˜(deflate, gzip)ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. ë˜í•œ serverì—ì„œ responseì˜ raw bodyë¥¼ ì¤€ë‹¤ë©´ custom Encoder functionì„ ì‚¬ìš©í•˜ì—¬ ì´ë¥¼ ë””ì½”ë”©í•  ìˆ˜ ìˆë‹¤.

f. defaultRequest
requestë¥¼ ë³´ë‚¼ ë•Œ í•­ìƒ ì„¤ì •ë˜ì—ˆìœ¼ë©´ í•˜ëŠ” ê±¸ headerì— ì¶”ê°€í•˜ê±°ë‚˜ base urlì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.
ì´ë²ˆ ê²½ìš°ì—” contentTypeì„ JSONìœ¼ë¡œ, accessToken(ìˆì„ ê²½ìš°ì—ë§Œ), base urlì„ ì„¤ì •í•´ì£¼ì—ˆë‹¤.


### 8. Usecaseì™€ ViewModelê³¼ì˜ ì—°ê²°
```kotlin
@HiltViewModel
class ScrapViewModel @Inject constructor(
    private val getScrapListUseCase: GetScrapList,
    private val getSubscribesUseCase: GetSubscribes,
    private val addScrapUseCase: AddScrap,
    private val deleteScrapUseCase: DeleteScrap,
): ViewModel(){

    ...

    private val _eventFlow = MutableSharedFlow<PEvent>()
    val eventFlow = _eventFlow

    private fun addScrap(contentId: Long){
        viewModelScope.launch{
            addScrapUseCase(contentId).collect { response ->
                when(response){
                    is Resource.Loading -> _eventFlow.emit(PEvent.LOADING)
                    is Resource.Success -> _eventFlow.emit(PEvent.ADD)
                    is Resource.Error -> _eventFlow.emit(PEvent.ERROR(response.message))
                }
            }
        }
    }
}
```

ì´ì œ viewModelì—ì„œ ì´ëŸ° ì‹ìœ¼ë¡œ ì“°ë©´ ëœë‹¤! ë! usecaseì—ì„œ ë°›ì•„ì˜¨ response ê°’ì— ë”°ë¼ ë‹¤ë¥¸ eventë¥¼ í˜¸ì¶œí•œë‹¤.

### 9. í…ŒìŠ¤íŠ¸ì½”ë“œ ì‘ì„±
```kotlin
@Test
fun addScrap_success(){
    runBlocking {
        // given
        val content = """{"success": true, "response": null, "error": null}"""
        val contentId = 1L

        // when
        val mock = getExceptionHttpClient(content)
        val data = ScrapApi(mock).addScrap(contentId).body<ApiUtils.ApiResult<String>>()

        // then
        Assert.assertEquals(true, data.success)
        Assert.assertEquals(null, data.response)
        Assert.assertEquals(null, data.error)
    }
}
```
mock apië¥¼ ë§Œë“¤ê³  ë”ë¯¸ ë°ì´í„°ë¥¼ ì–µì§€ë¡œ ë§Œë“¤ì–´ì„œ í…ŒìŠ¤íŠ¸ í•  ìˆ˜ ìˆë‹¤.

## ğŸš¨ë¬¸ì œ ë°œìƒê³¼ í•´ê²°
1. jvmTarget ë¬¸ì œ
retrofit ì“¸ ë• 1.8ë¡œ ì¨ë„ë¬¸ì œì—†ì—ˆëŠ”ë° jvmì„ ì§€ì›í•´ì£¼ì§€ ì•Šì•„ì„œ 17ë¡œ ë°”ê¿”ì•¼ í•œë‹¤... í•˜ì§€ë§Œ ë²„ì „ì„ ë°”ê¾¸ëŠ” ê±´ ì‰½ë‹¤.

2.  ContentNegotiation ë¬¸ì œ
    ì§„ì§œ ë¬¸ì œëŠ” ì–˜ì˜€ë‹¤. ì²˜ìŒì—” ë‹¤ë¥¸ ë¸”ë¡œê·¸ ê¸€ë“¤ì„ ì°¸ê³ í•˜ë©° ì‘ì„±í–ˆëŠ”ë° ê·¸ëŸ¬ë‹¤ ë³´ë‹ˆ êµ¬ë²„ì „ë“¤ (1.xx) ë°–ì— ì—†ì—ˆë‹¤. êµ¬ ë²„ì „ì—ì„  ì§€ì›í•˜ë˜ JsonFeatureê°€ 2.xxë¡œ ë°”ë€Œë©´ì„œ deprecatedë˜ê³  ContentNegotiationìœ¼ë¡œ ë°”ë€Œì—ˆë˜ ê²ƒì´ë‹¤.. ëˆ„ê°€ë´ë„ ë¹„ìŠ·í•œ ì ì´ ì—†ìœ¼ë‹ˆê¹Œ ì–´ë–¤ ë¶€ë¶„ì´ ì˜ëª»ëëŠ”ì§€ ëª°ë¼ì„œ í•œì°¸ í—¤ë§¸ë‹¤. 

    ìƒˆë¡œ ë§Œë“¤ì–´ì§„ì§€ ì–¼ë§ˆ ì•ˆëœ í”„ë ˆì„ì›Œí¬ë¼ ê·¸ëŸ° ê²ƒ ê°™ë‹¤.

    ì´ ë¸”ë¡œê·¸ ê¸€ì„ ë³´ëŠ” ëˆ„êµ°ê°€ ktorë¥¼ ì ìš©í•  ê³„íšì´ë¼ë©´ ë‹¤ë¥¸ ë¸”ë¡œê·¸ë“¤ì€ ì°¸ê³  ì •ë„ë¡œ ë³´ê³  ê³µì‹ í™ˆí˜ì´ì§€ ktor.io/docsë¥¼ ë³´ê³  ì‘ì„±í•˜ê¸¸ ì¶”ì²œí•œë‹¤.. ì§„ì‹¬ìœ¼ë¡œ..

3. Auth ë¬¸ì œ
    í† í°ì´ ë§Œë£Œë˜ë©´ 403 ì—ëŸ¬ê°€ ë‚˜ê²Œ ëœë‹¤. ì´ë•Œ Refreshë¥¼ ì‹œì¼œì¤˜ì•¼í•˜ëŠ”ë° ktorì—ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ì½”ë“œë¥¼ ì‘ì„±í•˜ë©´ ìë™ìœ¼ë¡œ í† í°ì„ ê°±ì‹ ì‹œì¼œì¤€ë‹¤.

    tokenì€ refresh í–ˆì„ ë•Œ response dataì´ë‹¤. ì„±ê³µí•˜ë©´ datastoreì— í•´ë‹¹ ë‚´ìš©ì„ ì €ì¥í•œë‹¤.

    ì´ë ‡ê²Œë§Œ ë³´ë©´ ì •ë§ ì¢‹ì€ pluginê°™ë‹¤... ê·¸ëŸ°ë° ì–´ë–¤ ìš”ì²­ì—” kakaoë¥¼ headerë¡œ, ì–´ë–¤ ìš”ì²­ì—” Authorizationì„ headerë¡œ ë„£ë‹¤ ë³´ë‹ˆ headerê°€ ê²¹ì³ì„œ ì—ëŸ¬ê°€ ë‚¬ë‹¤. ì´ë ‡ê²Œ ê²¹ì¹˜ëŠ” ìƒí™©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ì„  appendIfNameAbsentì„ ì ìš©í•´ì¤˜ì•¼í•œë‹¤.
 

## â¤ï¸ ëŠë‚€ì 
ë‹¨ìˆœí•œ í”„ë¡œì íŠ¸ë¥¼ í•˜ê¸° ìœ„í•´ì„œ ë„ì „! ë˜ëŠ” KMMì„ ì ìš©í•˜ê³  ì‹¶ì€ ë¶„ë“¤ì—ê²ŒëŠ” ì¶”ì²œí•œë‹¤.

í•˜ì§€ë§Œ retrofitê³¼ ë¹„êµí•´ë´¤ì„ ë•Œ retrofitì´ ì•„ì§ê¹Œì§€ëŠ” referenceë„ ë§ê³  ì—ëŸ¬ì— ëŒ€í•œ ë‹¤ì–‘í•œ í•´ê²°ë°©ë²•ì´ ì¡´ì¬í•œë‹¤ëŠ” ì ì—ì„œ ë” ì¢‹ì€ ê²ƒ ê°™ë‹¤.

ë‹¤ìŒ í”„ë¡œì íŠ¸ë¥¼ í•˜ê²Œ ë˜ë©´ ë‹¤ì‹œ retrofit2ë¡œ ëŒì•„ê°€ì•¼ê² ë‹¤.. ê·¸ë¦¬ì›Œ ğŸ˜¥


## ğŸ”— ì°¸ê³  ìë£Œ
[Retrofit2 ëŒ€ì‹  KtorëŠ” ì–´ë– ì‹ ê°€ìš”?](https://daryeou.tistory.com/345)

[ìœ íŠœë¸Œ](https://www.youtube.com/watch?v=3KTXD_ckAX0&t=1140s_)

[ktor ê³µì‹ ì‚¬ì´íŠ¸](https://ktor.io/)